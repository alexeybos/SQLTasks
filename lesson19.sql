--Сразу общие мысли, относящиеся к большинству запросов:
--1. (главное) По старой привычке, привитой на первой работе, "опускаю" ключевое слово JOIN и записываю таблицы через запятую, прописывая условия объединения в секции WHERE.
--2. Так же в плане оформления не привык писать ключевые слова заглавными буквами (у нас это не требуют, а это опять же наследие первой работы).

--1. Получить информацию о всех гномах, которые входят в какой-либо отряд, вместе с информацией об их отрядах.
select d.*, s.* from Dwarves d, Squads s
where s.squad_id = d.squad_id
order by s.name, d.name;

--Отличия от эталонного решения:
--Не указал конкретные поля для выбора, т.к. слишком "широко" интрепретировал требование "Получить информацию"

--2. Найти всех гномов с профессией "miner", которые не состоят ни в одном отряде.
select d.* from Dwarves d
where d.profession = 'miner' and d.squad_id is null;

--Решение идентично эталонному (кроме списка колонок выборки)

--3. Получить все задачи с наивысшим приоритетом, которые находятся в статусе "pending".
select * from Tasks t 
where t.status = 'pending'
and t.priority = (select max(t1.priority) from Tasks t1 where t1.status = 'pending');

--Решение идентично эталонному (кроме списка колонок выборки)
--Также еще чтобы не возникало путаницы, таблицы в основном запросе и в подзапросе имеют каждая свой алиас.
--Порядок следования условий в WHERE в данном случае на производительность запроса не должен влиять.

--4. Для каждого гнома, который владеет хотя бы одним предметом, получить количество предметов, которыми он владеет.
select d.name, count(*) from Dwarves d, Items i
where d.dwarf_id = i.owner_id
group by d.name;

--1. Список колонок выборки отличается (соответственно отличается наполнение секции GROUP BY). Ну и не очень красиво оформлен: COUNT(*), например, без читаемого алиаса
--2. В решении я использовал COUNT(*), а не COUNT(i.item_id), т.к.: 
--	а) В целом рекомендуют использовать (*) по причине вероятно лучшей производительности на больших данных - опять же, наверное, больше привычка (ну или лень - * быстрее поставить)
--	б) В подсчете нет необходимости учитывать вероятность значения NULL в i.item_id

--5. Получить список всех отрядов и количество гномов в каждом отряде. Также включите в выдачу отряды без гномов.
select s.name, count(d.dwarf_id) from Squads s
left outer join Dwarves d on s.squad_id = d.squad_id
group by s.name;

--Решение идентично эталонному (кроме списка колонок выборки)
--В данном случае использован COUNT(d.dwarf_id), т.к. тут уже считаем не строки, а конкретные id, которые могут быть NULL

--6. Получить список профессий с наибольшим количеством незавершённых задач ("pending" и "in_progress") у гномов этих профессий.
select d.profession, count(t.task_id) as cnt from Dwarves d, Tasks t
where d.dwarf_id = t.assigned_to
and t.status in ('pending', 'in_progress')
group by d.profession
order by cnt desc;

--Решение идентично эталонному
--Ну и видимо COUNT(t.task_id) тут по инерциии от предыдущего задания :)

--7. Для каждого типа предметов узнать средний возраст гномов, владеющих этими предметами.
select i.type, avg(d.age) from Dwarves d, Items i
where d.dwarf_id = i.owner_id
group by i.type;

--Решение идентично эталонному

--8. Найти всех гномов старше среднего возраста (по всем гномам в базе), которые не владеют никакими предметами. 
select * from Dwarves d
where not exists (select i.item_id from Items i where i.owner_id = d.dwarf_id)
and d.age > (select avg(d1.age) from Dwarves d1);

--1. Не оформлены колонки результат выборки
--2. Использована конструкция not exists, т.к. описывается как более предпочтительная для больших данных. В данном случае конечно особой разницы при использовании NOT IN или NOT EXISTS нет.
